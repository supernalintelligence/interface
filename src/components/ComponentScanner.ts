/**
 * Component Scanner for data-testid attributes
 * 
 * Scans React/Next.js components for data-testid attributes and generates
 * type-safe component name contracts.
 * 
 * @example
 * ```typescript
 * const scanner = new ComponentScanner({
 *   projectRoot: '/path/to/project',
 *   componentsDir: 'apps/dashboard/src/components',
 *   outputPath: 'src/lib/names/Components.ts'
 * });
 * 
 * const result = await scanner.scan();
 * await scanner.generate(result);
 * ```
 */

import * as fs from 'fs';
import * as path from 'path';
import { glob } from 'glob';
import type {
  ContractScanner,
  ScanResult,
  ContractEntry,
  GenerateOptions,
  MigrateOptions,
  MigrateResult
} from '../name-contracts/ContractScanner';

export interface ComponentScannerConfig {
  projectRoot: string;
  componentsDir: string;
  outputPath?: string;
}

export interface ComponentScanResult extends ScanResult {
  testIds: Map<string, string[]>;
  domains: Map<string, Array<{ key: string; value: string }>>;
}

export interface ComponentMigrationChange {
  file: string;
  originalContent: string;
  newContent: string;
  modifications: string[];
  replacements: Array<{ testId: string; replacement: string }>;
  backupPath: string | null;
}

export interface ComponentMigrateResult extends MigrateResult {
  changeDetails?: ComponentMigrationChange[];
}

export class ComponentScanner implements ContractScanner {
  readonly type = 'components';
  readonly description = 'Scans React components for data-testid attributes';
  
  private projectRoot: string;
  private componentsDir: string;
  private outputPath: string;

  constructor(config: ComponentScannerConfig) {
    this.projectRoot = config.projectRoot;
    this.componentsDir = config.componentsDir;
    this.outputPath = config.outputPath || path.join(this.projectRoot, 'src/lib/names/Components.ts');
  }

  getDefaultOutputPath(): string {
    return this.outputPath;
  }

  /**
   * Scan codebase for data-testid attributes
   */
  async scan(): Promise<ComponentScanResult> {
    const fullComponentsDir = path.isAbsolute(this.componentsDir)
      ? this.componentsDir
      : path.join(this.projectRoot, this.componentsDir);
    
    const files = await glob('**/*.tsx', { cwd: fullComponentsDir });
    
    const testIds = new Map<string, string[]>();
    const contracts = new Map<string, ContractEntry>();
    
    for (const file of files) {
      const filePath = path.join(fullComponentsDir, file);
      const content = fs.readFileSync(filePath, 'utf-8');
      
      // Extract data-testid values
      const regex = /data-testid=["']([^"']+)["']/g;
      let match: RegExpExecArray | null;
      
      while ((match = regex.exec(content)) !== null) {
        const testId = match[1];
        if (!testIds.has(testId)) {
          testIds.set(testId, []);
        }
        testIds.get(testId)!.push(file);
        
        // Add to contracts map
        const contractName = this.testIdToContractName(testId);
        if (!contracts.has(testId)) {
          contracts.set(testId, {
            name: contractName,
            value: testId,
            files: [file],
            category: this.inferCategory(file)
          });
        } else {
          contracts.get(testId)!.files.push(file);
        }
      }
    }
    
    // Group by domain (infer from file paths)
    const domains = this.groupByDomain(testIds);
    
    return {
      contracts,
      testIds,
      domains,
      metadata: {
        scanDate: new Date().toISOString(),
        totalComponents: testIds.size,
        totalDomains: domains.size
      }
    };
  }

  /**
   * Generate Components.ts from scan results
   */
  async generate(result: ComponentScanResult, options: GenerateOptions): Promise<string> {
    const { domains } = result;
    const outputPath = options.outputPath || this.outputPath;
    
    let output = `/**
 * UI Component Name Contracts (Auto-generated)
 * 
 * Last updated: ${new Date().toISOString()}
 * Generated by: ComponentScanner
 * 
 * @packageDocumentation
 */

export const Components = {\n`;
    
    for (const [domain, items] of domains.entries()) {
      const domainKey = domain.charAt(0).toUpperCase() + domain.slice(1);
      output += `  /** ${domainKey} */\n`;
      output += `  ${domainKey}: {\n`;
      
      for (const { key, value } of items.sort((a, b) => a.key.localeCompare(b.key))) {
        output += `    ${key}: '${value}',\n`;
      }
      
      output += `  },\n\n`;
    }
    
    output += `} as const;\n\n`;
    output += `// Type exports\n`;
    output += `export type ComponentNames = typeof Components;\n`;
    output += `export type ComponentID = ComponentNames[keyof ComponentNames][keyof ComponentNames[keyof ComponentNames]];\n`;
    
    // Write to file if not dry-run
    if (!options.dryRun) {
      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      fs.writeFileSync(outputPath, output, 'utf-8');
    }
    
    return output;
  }

  /**
   * Migrate component files to use name contracts
   */
  async migrate(options: MigrateOptions): Promise<ComponentMigrateResult> {
    const { dryRun = false, createBackup = true } = options;
    const fullComponentsDir = path.isAbsolute(this.componentsDir)
      ? this.componentsDir
      : path.join(this.projectRoot, this.componentsDir);
    
    const files = await glob('**/*.tsx', { cwd: fullComponentsDir });
    
    const changeDetails: ComponentMigrationChange[] = [];
    
    for (const file of files) {
      const filePath = path.join(fullComponentsDir, file);
      const originalContent = fs.readFileSync(filePath, 'utf-8');
      let content = originalContent;
      let modified = false;
      const modifications: string[] = [];
      
      // Check if already imports Components
      if (!content.includes("from '@/lib/names'")) {
        // Add import at top (after 'use client' if present)
        const lines = content.split('\n');
        const insertIndex = lines.findIndex(line => 
          !line.startsWith("'use client'") && 
          !line.startsWith('/**') && 
          !line.startsWith('//') &&
          line.trim() !== ''
        );
        
        if (insertIndex !== -1) {
          lines.splice(insertIndex, 0, "import { Components } from '@/lib/names';");
          content = lines.join('\n');
          modified = true;
          modifications.push('Added import');
        }
      }
      
      // Replace hardcoded strings with Components references
      const testIds = [...originalContent.matchAll(/data-testid=["']([^"']+)["']/g)];
      const replacements: Array<{ testId: string; replacement: string }> = [];
      
      for (const match of testIds) {
        const testId = match[1];
        const replacement = this.findComponentReference(testId);
        
        if (replacement) {
          // Replace both single and double quote variants
          content = content.replace(
            new RegExp(`data-testid=["']${testId}["']`, 'g'),
            `data-testid={Components.${replacement}}`
          );
          modified = true;
          replacements.push({ testId, replacement });
        }
      }
      
      if (modified) {
        if (!dryRun) {
          // Create backup if requested
          if (createBackup) {
            fs.writeFileSync(`${filePath}.backup`, originalContent, 'utf-8');
          }
          
          // Write changes
          fs.writeFileSync(filePath, content, 'utf-8');
        }
        
        changeDetails.push({
          file,
          originalContent,
          newContent: content,
          modifications,
          replacements,
          backupPath: createBackup ? `${filePath}.backup` : null
        });
      }
    }
    
    return {
      changes: changeDetails.length,
      skipped: files.length - changeDetails.length,
      files: changeDetails.map(c => c.file),
      changeDetails
    };
  }

  /**
   * Validate contracts match actual codebase
   */
  async validate(): Promise<string[]> {
    const errors: string[] = [];
    
    // Scan current codebase
    const result = await this.scan();
    const testIds = result.testIds;
    
    // Load existing contracts if they exist
    if (!fs.existsSync(this.outputPath)) {
      errors.push('Components.ts does not exist - run generate first');
      return errors;
    }
    
    const contractIds = this.getAllContractIds();
    
    // Check that all contracts exist in codebase
    for (const contractId of contractIds) {
      if (!testIds.has(contractId)) {
        errors.push(`Contract exists but not found in code: ${contractId}`);
      }
    }
    
    // Check that all codebase IDs have contracts
    for (const [testId] of testIds.entries()) {
      if (!contractIds.includes(testId)) {
        errors.push(`Component exists but has no contract: ${testId}`);
      }
    }
    
    return errors;
  }

  /**
   * Rollback migration using backup files
   */
  async rollback(): Promise<string[]> {
    const fullComponentsDir = path.isAbsolute(this.componentsDir)
      ? this.componentsDir
      : path.join(this.projectRoot, this.componentsDir);
    
    const backupFiles = await glob('**/*.tsx.backup', { cwd: fullComponentsDir });
    const restored: string[] = [];
    
    for (const backupFile of backupFiles) {
      const backupPath = path.join(fullComponentsDir, backupFile);
      const originalPath = backupPath.replace('.backup', '');
      
      try {
        const backupContent = fs.readFileSync(backupPath, 'utf-8');
        fs.writeFileSync(originalPath, backupContent, 'utf-8');
        fs.unlinkSync(backupPath);
        
        restored.push(originalPath);
      } catch (error) {
        const errMsg = error instanceof Error ? error.message : 'Unknown error';
        throw new Error(`Failed to restore ${originalPath}: ${errMsg}`);
      }
    }
    
    return restored;
  }

  /**
   * Clean up backup files
   */
  async cleanupBackups(): Promise<number> {
    const fullComponentsDir = path.isAbsolute(this.componentsDir)
      ? this.componentsDir
      : path.join(this.projectRoot, this.componentsDir);
    
    const backupFiles = await glob('**/*.tsx.backup', { cwd: fullComponentsDir });
    
    for (const backupFile of backupFiles) {
      const backupPath = path.join(fullComponentsDir, backupFile);
      fs.unlinkSync(backupPath);
    }
    
    return backupFiles.length;
  }

  // ========== Private Helper Methods ==========

  /**
   * Group test IDs by domain (inferred from file paths)
   */
  private groupByDomain(testIds: Map<string, string[]>): Map<string, Array<{ key: string; value: string }>> {
    const domains = new Map<string, Array<{ key: string; value: string }>>();
    
    for (const [testId, files] of testIds.entries()) {
      const firstFile = files[0];
      const parts = firstFile.split('/');
      const domain = parts[0] || 'General';
      
      if (!domains.has(domain)) {
        domains.set(domain, []);
      }
      
      const key = this.testIdToContractName(testId);
      domains.get(domain)!.push({ key, value: testId });
    }
    
    return domains;
  }

  /**
   * Convert kebab-case test ID to PascalCase contract name
   */
  private testIdToContractName(testId: string): string {
    return testId
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  }

  /**
   * Infer category (domain) from file path
   */
  private inferCategory(filePath: string): string {
    const parts = filePath.split('/');
    return parts[0] || 'General';
  }

  /**
   * Find component reference path (e.g., "Compliance.SecurityView")
   */
  private findComponentReference(testId: string): string | null {
    if (!fs.existsSync(this.outputPath)) return null;
    
    const content = fs.readFileSync(this.outputPath, 'utf-8');
    
    // Parse structure to find matching path
    const regex = new RegExp(`(\\w+):\\s*{[^}]*\\s+(\\w+):\\s*'${testId}'`, 'g');
    const match = regex.exec(content);
    
    if (match) {
      return `${match[1]}.${match[2]}`;
    }
    
    return null;
  }

  /**
   * Get all contract IDs from Components.ts
   */
  private getAllContractIds(): string[] {
    if (!fs.existsSync(this.outputPath)) {
      return [];
    }
    
    const content = fs.readFileSync(this.outputPath, 'utf-8');
    
    const regex = /:\s*'([^']+)'/g;
    const ids: string[] = [];
    let match: RegExpExecArray | null;
    
    while ((match = regex.exec(content)) !== null) {
      ids.push(match[1]);
    }
    
    return ids;
  }
}

